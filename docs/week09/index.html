<!-- uses https://highlightjs.org/
-->

<html>

<head>
  <link rel="shortcut icon" href="https://byui-cse.github.io/Language-Courses/site/images/fav.ico" type="image/x-i        con">
    <script type="text/javascript">
                 var codeType = "Clojure"
    </script>
    <script src="https://byui-cse.github.io/Language-Courses/site/highlight.pack.js"></script>
    <link rel="stylesheet" href="https://byui-cse.github.io/Language-Courses/site/highlight_styles/xcode.css">
    <link rel="stylesheet" href="https://byui-cse.github.io/Language-Courses/site/weekly.css">
    <script type="text/javascript" src="https://byui-cse.github.io/Language-Courses/site/weekly.js"></script>
    <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML">
    </script>

    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [['\\(', '\\)']]
        }
    });
    MathJax.Hub.Config({
        TeX: {
            equationNumbers: {
                autoNumber: "AMS"
            }
        }
    });
    MathJax.Hub.Config({
        "HTML-CSS": {
            availableFonts: [],
            preferredFont: null,
            // force Web fonts
            webFont: "Latin-Modern"
        }
    });
    MathJax.Hub.Config({
        TeX: {
            extensions: ["color.js"]
        }
    });
    </script>

</head>

<body onload="fetchSource()">
<div class="hero-image">
  <div class="hero-text">
    <h1>CSE 382: Week 09</h1>
    <p>Heaps</p>
  </div>
</div>
\(
\newcommand\when{\text{ } when\text{ }}
\newcommand\otherwise{\text{ } otherwise\text{ }}
\)
<blockquote class="style1">
    <span>Generally, the craft of programming is the factoring of a set of requirements into a a set of functions and data structures.</span>
    <p class="style1">- Douglas Crockford</p>
  </blockquote>

<h2>The Heap Data Structure</h2>
<p>
  Binary Search Trees are amazing things, but sometimes they don't fit the problem. There are many ways that a 
  heap could be implemented. In functional programming it is common to leverage the concept of a tree for the 
  pattern of a heap. The difference between a tree and the heap data structure described here is the ordering 
  rule. In a minimum heap, known as a min-heap, the least value is the one of interest, therefore it is kept at the root. When adding a value 
  to a heap, if the new value is less than the root, the new value becomes the root of the tree. If the new value 
  is greater than the root, another rule is used to place the value in the tree. Regardless of what the rule is 
  for insertion in the tree, the new value will either be a new leaf in the tree or the least value of a sub-tree. 
</p>
<h3>Leftist Min-Heaps</h3>
<p>
  The ordering rule of min-heaps is this. The data for each of the sub-nodes is less than the data of the parent node. For leftist heaps, left sub-nodes can or can not exist for any node, but if there is a right node, there must first have been a left node added. Being a min-heap, the \(get\_min\) function has a complexity of \(\mathcal{O}(1)\). You can deduce this from the code below which uses a Maybe from week 6.
</p>

\[\begin{align*}
    get\_min\ &::\ node\rightarrow a:::Maybe\\
    \\
    get\_min\text{ }&::\ nil\rightarrow\\
               &\ \{fail,nil\};\\
    get\_min\ &::\ \{rank,value,next_l,next_r\} \rightarrow\\
               &\ \{ok,value\}.
\end{align*}\]
<p>
  To insert a value into a heap, a fa&ccedil;ade function is used called \(insert\). In the code snippet below this function calls the \(merge\) function that has two parameters, the heap to insert the value into and the value. This creates a single heap node for the value being inserted and adds it to the indicated heap.
</p>  
\[\begin{align*}

    insert\ &::\ value\ node\rightarrow b:::Maybe\\
    \\
    insert\ &::\ nil\ nil\rightarrow\\
            &\{fail,nil\};\\
    insert\ &::\ value\ nil\rightarrow\\
            &\{ok,\{1,value,nil,nil\}\};\\
    insert\ &::\ value\ root\rightarrow\\
    &merge:: \{1,value,nil,nil\}\ root.\\
\end{align*}\]
<p>
  This means that \(merge\) does all the work for both inserting a value and merging two heaps, \(h\) and \(i\) in the snippet below.
</p>
\[\begin{align*}
    merge\ &::\ h\ i\rightarrow root\\
    \\
    merge\ &::\ nil\ nil\rightarrow\\
               &nil;\\
    merge\ &::\ nil\ i\rightarrow\\
               &i;\\
    merge\ &::\ h\ nil\rightarrow\\
               &h;\\
    merge\ &::\ h\ i \rightarrow\\
        &i\looparrowright \{i\_rank,i\_value,il\_sub,ir\_sub\}\\
        &h\looparrowright \{h\_rank,h\_value,hl\_sub,hr\_sub\}\\
        &case\\
               &\quad rank\_and\_swap\ \{h\_rank,h\_value,hl\_sub,(merge\ hr\_sub\ i)\}\when h\_value\le i\_value \\
               &\quad rank\_and\_swap\ \{i\_rank,i\_value,il\_sub,(merge\ h\ ir\_sub)\}\otherwise.

\end{align*}\]

<p>
    In the above pseudocode, at each level of the heap, the right-side heap spines are merged and, if needed, the sub-heaps are swapped. This swapping is done by the \(rank\_and\_swap\) helper algorithm when the rank of the left sub-heap is less than the rank of the right sub-heap, thus enforcing the leftist requirement. The swap algorithm also updates the rank of the current root as needed. The pseudocode for the \(rank\_and\_swap\) algorithm is seen below. 
</p>
\[\begin{align*}
    rank\_and\_swap\ ::&\ root\rightarrow root\\
    \\
    rank\_and\_swap\ ::&\ nil\rightarrow nil;\\
    rank\_and\_swap\ ::&\ \{rank,value,nil,\{r\_rank,r\_value,rl\_sub,rr\_sub\}\}\rightarrow\\
            & \{1,value,\{r\_rank,r\_value,rl\_sub,rr\_sub\},nil\};\\
    &\%\%\text{This next clause handles the 'do no swap only update rank' case.}\\
    rank\_and\_swap\ ::&\ \{rank,value,\{l\_rank\ l\_value,ll\_sub,lr\_sub\},\{r\_rank,r\_value,rl\_sub,rr\_sub\}\} when\ l\_rank \ge r\_rank\rightarrow\\
            &\{r\_rank+1,value,\{l\_rank,l\_value,ll\_sub,lr\_sub\},\{r\_rank,r\_value,rl\_sub,rr\_sub\}\};\\
    rank\_and\_swap\ ::&\ \{rank,value,\{l\_rank,l\_value,ll\_sub,lr\_sub\},\{r\_rank,r\_value,rl\_sub,rr\_sub\}\} otherwise\rightarrow\\
            &\{l\_rank+1,value,\{r\_rank,r\_value,rl\_sub,rr\_sub\},\{l\_rank,l\_value,ll\_sub,lr\_sub\}\}.
\end{align*}\]

<h3>Data Removal</h3>
<p>
Being a min-heap, usually the only element that is 'popped' or removed is the least element. When the least element is removed its child nodes must be stitched back together via merging.
</p>

\[\begin{align*}
    remove\_min\ &::\ node\rightarrow b:::Maybe\\
    \\
    remove\_min\ &::\ nil\rightarrow\\
               &\{fail,nil\};\\
    remove\_min\ &::\ \{rank,value,next\_l,next\_r\}\rightarrow\\
               &\{ok,merge\ ::\ next\_r\text{ }next\_l\}.
\end{align*}\]

<footer>
<a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.
</footer>
</body>
</html>
