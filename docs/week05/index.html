<!-- uses https://highlightjs.org/
-->

<html>

<head>
	<link rel="shortcut icon" href="https://byui-cse.github.io/Language-Courses/site/images/fav.ico" type="image/x-i        con">
    <script type="text/javascript">
                 var codeType = "Clojure"
    </script>
    <script src="https://byui-cse.github.io/Language-Courses/site/highlight.pack.js"></script>
    <link rel="stylesheet" href="https://byui-cse.github.io/Language-Courses/site/highlight_styles/xcode.css">
    <link rel="stylesheet" href="https://byui-cse.github.io/Language-Courses/site/weekly.css">
    <script type="text/javascript" src="https://byui-cse.github.io/Language-Courses/site/weekly.js"></script>
    <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML">
    </script>

    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [['\\(', '\\)']]
        }
    });
    MathJax.Hub.Config({
        TeX: {
            equationNumbers: {
                autoNumber: "AMS"
            }
        }
    });
    MathJax.Hub.Config({
        "HTML-CSS": {
            availableFonts: [],
            preferredFont: null,
            // force Web fonts
            webFont: "Latin-Modern"
        }
    });
    MathJax.Hub.Config({
        TeX: {
            extensions: ["color.js"]
        }
    });
    </script>


</head>

<body onload="fetchSource()">
<div class="hero-image">
  <div class="hero-text">
    <h1>CSE 382: Week 05</h1>
    <p>The Currying Pattern</p>
  </div>
</div>

  <blockquote class="style1">
    <span>Currying is an incredibly useful technique...It allows you to generate a library of small, easily configured functions that behave consistently, are quick to use, and that can be understood when reading your code..</span>
    <p class="style1">- M. David Green</p>
  </blockquote>

<h2>The Anti-Pattern of Ugliness</h2>
<p>
  Why is some code ugly? There are a lot reasons...to many to describe. It's easier to describe what 
  is meant by beautiful code.
</p>
<p>
  <aside class="left_wide">
    
  <figcaption>Fig. 1 - Principles of Beautiful Code</figcaption>
  <figure>Beautiful code is;
    <ul>
      <li>Distilled. There is nothing extraneous or verbose.</li>
      <li>Balanced. Calculations are distributed between deeply thought out and clearly articulated calculation 
      units.</li>
      <li>Harmonious. The calculation units unite in the reader's mind without cognitive conflict to describe how to accomplish the overall task.</li>
      <li>Audacious and Original. Beautiful code surprises the reader by showing new ways to think about a problem.</li>
      <li>Full of Imagery. Words and names are selected to clearly, and with impact, inform the reader what they 
      represent.</li>
      <li>Structured. The location of the code and its design is as important as what the code says.</li>
      <li>Compassionate. Reading the code is a fun and easy undertaking.</li>
    </ul>
  </figure>
  </aside>
</p>
<p>
   Given this definition, beautiful code is easier to read and comprehend, therefore it is easier to debug. 
   For this same reason, it is also easier to extend. Anything that doesn't match this definition might not 
   be outright ugly, but should be improved if for no other reason that to make supporting the code easier.
</p>
  <p>
    Now consider a situation similar to, but not the same as, the map-filter-reduce situation described in the 
    <a href="https://byui-cse.github.io/cse121e-course/week03/index.html" target="_blank">CSE 121E</a> or <a href="https://byui-cse.github.io/cse121a-course/week04/" target="_blank">CSE 121A</a> course reading</a>. Now think about a new situation. You have been asked to map, then filter, and then reduce some list. 
    Maybe you've been asked to work with a list of numbers, double them all, keep only those that are greater 
    than 50, and then add up all that remain. If you use the map, filter, and reduce BIF's in a raw way, the 
    generic version of the code to do what you were asked to write looks like this.
  </p>
  <p>
    \[ 
    reduce\text{ }::\text{ }(filter\text{ }::\text{ }(map\text{ }::\text{ }[a]\text{ }f_1\rightarrow [b])
    \text{ }f_2\rightarrow [c])\text{ }f_3\text{ }\rightarrow d\]
  </p>
  <p>
    This code is not harmonious. To understand it, you eventually have to realize that you need to read it 
    from the inside to the outside using order of operations as a guide. That time before you have that 
    realization is cognitive conflict and is, therefore, not harmonious. For this 
    same inside-to-outside reason is also why it is not structured well, violating another principle of 
    beautiful code.
  </p>
  <p>
    While those two reasons are enough to make this code ugly, the problems don't end there. The code is also 
    verbose. Being verbose, it is not distilled. Look at all of those duplicated list notations. Each is just 
    a variation of the last. Why, then, do they have to be there? There is also the name of each function that 
    needs to be used. Again, why? 
  </p>
  <p>
    Is the code compassionate? Not even close. Is it audacious? Nope. It's very pedestrian. If you think about this 
    code snippet some more, you'll find it violates most, if not all, of the principles of beautiful code.
  </p>
  <p>
    The type of code writing exhibited by the above code is evidence that the programmer doesn't understand the 
    possibilities offered by functional programming languages and those that are functional-like. Is there, then, another way?
  </p>
  <h2>Achieving Beauty</h2>
  
  <h4>Chaining</h4>
  <p>
    When considering how to reduce some of the ugliness found in code around the world, it is vital, with any language type, to know and understand all the options that the type of language offers. It is true that functional programming languages, higher-order functions can have a parameter that is a lambda. It is also true that higher-order functions can have a lambda as their value. This may seem strange. Why would such a thing as having a lambda as the value of a function be useful?
  </p>
  <p>
    Take a look at the ugly <kbd>map</kbd>, <kbd>filter</kbd>
    , <kbd>reduce</kbd> code snippet above. It would be much improved if the order of the calls to <kbd>map</kbd>, <kbd>filter</kbd>, and <kbd>reduce</kbd> were listed from left to right. You can do this if you put the calls to the functions into a chain, a series of calls functions to be done.
  </p>
  <aside class="right">
  <figure>
    <dfn>Chaining</dfn> - the process of executing a series of functions where the output of one is used as the input for the next.
  </figure>
    <figcaption>Fig. 2</figcaption>
  </aside>
  <p>
    If we take another look at how the <kbd>map-filter-reduce</kbd> example above could be written using chaining, beauty emerges. To make this happen, we need to create a list that we choose to call <kbd>links</kbd> where each lambda to be applied to is a link and each link is in the desired order of execution. But before we take express <kbd>chain</kbd> using pseudocode let's express it in mathematical notation. Doing so, it would look like this \([f_1,f_2,f_3]\).
  </p>
  <p>
   Consider a situation where you have a series of numbers and need to double them, keep only those results which are greater than 200, and then sum them. You can put together a list of functions or lambdas that apply a mapping that does the doubling, a filtering that keeps only those greater than 200, and then a reduction that sums those that are left. Then what is needed is a function to execute each of those functions. Let's call that function <kbd>chain</kbd> and pass it the links and the data to act on. The code below shows <kbd>chain</kbd> as a facade function with <kbd>chain_worker</kbd> being the function that does the actual computation.
  </p>
  \[
    \begin{align*}
    chain\text{ }&::\text{ }links\text{ }a\rightarrow b\\
    \\
    chain\text{ }&::\text{ }links\text{ }a\rightarrow \\
    &chain\_worker\text{ }::\text{ }(rev\ links)\ a.\\
    \\
    chain\_worker\text{ }&::\text{ }reversed\_links\text{ }a\rightarrow b\\
    \\
    chain\_worker\text{ }&::\ []\ a\rightarrow\ a;\\
    chain\_worker\text{ }&::\text{ }[h\mid t]\text{ }a\rightarrow\\
    &h\text{ }::\text{ }(chain\_worker\text{ }::\text{ }t\text{ }a).
    \end{align*}
    \]
  <p>
  Notice that <kbd>chain</kbd> reverses the list of links. This ensures that the functions are executed in the intended order as <kbd>chain_worker</kbd> gets called recursively. Also not that \(a\) and \(b\) in the pseudocode can be of the same type or their types can differ. Additionally, \(a\) can be any type. It is not limited to being a list.
  </p>
  <p>
    While the use of this pattern does lend to the code being more beautiful than the original inside-to-outside <kbd>map-filter-reduce</kbd> example, it is still not as beautiful as it could be. It still uses more lines of code than necessary, is not very audacious, and requires the list to be reversed. Therefore, it could be viewed as an anti-pattern in functional programming. There is a much better option, your language's <kbd>foldl</kbd> BIF if it has one. Using this BIF, all of the code for the <kbd>chain</kbd> function goes away. It isn't needed. The single line of code below replaces it.
  </p>
  \[
    \begin{align*}
    foldl\text{ }&::\text{ }(\lambda\text{ }::\text{ }link\_to\_apply\text{ }value \rightarrow (link\_to\_apply\text{ }::\text{ }value))\text{ }values\text{ }links
    \end{align*}
  \]

  <p>
    If your language doesn't have <kbd>foldl</kbd>, you can still reverse the <kbd>links</kbd> list and apply the <kbd>foldr</kbd> BIF.
  </p>
  <p>
    Chaining can be a very useful pattern when a series of functions or lambdas can be considered as a single computational unit. Sometimes the opposite of combining is needed. Then you use currying.
  </p>

    <h3>Currying</h3>
  <p>
    Currying, in Computer Science and Mathematics, is named after the mathematician Haskell 
    Curry and he based this part of his work on what was previously accomplished by Moses Sch&ouml;nfinkel and 
    Gottlob Frege.
  </p>
  <aside class="left">
  <figure>
    <dfn>Currying</dfn> - the process of breaking up a function that has \(n\) parameters into \(n\) 
    functions that have 1 parameter.
  </figure>
    <figcaption>Fig. 3</figcaption>
  </aside>
  <p>
    The basic idea behind currying is to map a function that has multiple parameters to a series of functions 
    that each have only one. Then, by executing each of the functions, the same result can be achieved. For 
    example, you could think of this as \(f(a,b)\) being the same as \(f(a)(b)\) if \(f(a)\) returned a 
    function that was then passed the parameter \(b\). 
    What you are really doing here, is storing parameters that you do have while you wait for those you don't have yet.
  </p>
  <p>
    It may seem strange that a function could or should return a function, but that's one of the principles 
    that allows functional programming languages to deeply leverage lambdas. Functions, in a functional 
    programming language, are first-class citizens. Or said differently, you can treat a function like 
    anything other type in the language. It can be stored in a variable. It be passed as a parameter. It can 
    be returned from another function.
  </p>
    <p>
      On of the very beautiful things about the currying in general, is how it can more closely map a function requiring multiple parameters to a real world situation. Consider how people interact with an ATM (cash machine). First they enter a card, then a pin, and finally they indicate what transaction type they want. These three pieces of data could be acted on  by a single function after the data has been collected. This is traditionally what you would see in code and the function could be something like \(perform\_transaction\text{ }::\text{ }card\_number\text{ }pin\text{ }transaction\_id\rightarrow boolean\).
    </p>
    <p>
      If, however, this behavior was curried, the code would be called like this.</kbd>
    </p>
    \[curried\_perform\text{ }::\text{ }card\_number\text{ }::\text{ }pin\text{ }::\text{ }transaction\_id\rightarrow success\]
    <p>
      Notice that each function except for the last returns a lambda that is passed an additional, single piece of data. The currying process is accumulating the parameters. When all of the parameters have been passed, the execution of the code can proceed. For this to happen, there needs to be 'partial application' of each parameter as it is received. 
    </p>
    <p>
      Now be careful and be wise. Remember that your code must be beautiful. If you start using currying 
      when other choices would be better, your code will quickly digress into ugliness. Use currying to add 
      beauty.
    </p>


<footer>
<a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.
</footer>
</body>
</html>
